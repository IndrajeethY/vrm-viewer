<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Lewd VRM Poses Viewer</title>
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<style>
			body {
				margin: 0;
				font-family: 'Inter', sans-serif;
				overflow: hidden;
			}
			canvas {
				display: block;
				width: 100vw;
				height: 100vh;
			}
			.sidebar {
				position: absolute;
				top: 0;
				left: 0;
				width: 320px;
				height: 100vh;
				background: rgba(15, 15, 20, 0.95);
				color: white;
				z-index: 100;
				display: flex;
				flex-direction: column;
				box-shadow: 4px 0 15px rgba(0, 0, 0, 0.5);
				overflow: hidden;
			}
			.sidebar-header {
				padding: 15px;
				background: linear-gradient(145deg, #1a1a2e, #16213e);
				border-bottom: 1px solid #333;
			}
			.sidebar-header h2 {
				margin: 0 0 10px 0;
				font-size: 18px;
				color: #fc5c7d;
			}
			.sidebar-header .model-info {
				font-size: 12px;
				color: #888;
			}
			.pose-categories {
				flex: 1;
				overflow-y: auto;
				padding: 10px;
			}
			.pose-category {
				margin-bottom: 8px;
				border-radius: 8px;
				overflow: hidden;
				background: rgba(30, 30, 40, 0.8);
			}
			.category-header {
				padding: 12px 15px;
				background: linear-gradient(145deg, #2d2d44, #1f1f2e);
				cursor: pointer;
				display: flex;
				justify-content: space-between;
				align-items: center;
				font-weight: bold;
				font-size: 13px;
				transition: background 0.2s;
			}
			.category-header:hover {
				background: linear-gradient(145deg, #3d3d54, #2f2f3e);
			}
			.category-header .arrow {
				transition: transform 0.2s;
			}
			.category-header.expanded .arrow {
				transform: rotate(90deg);
			}
			.category-content {
				display: none;
				padding: 8px;
				background: rgba(20, 20, 30, 0.5);
			}
			.category-content.show {
				display: block;
			}
			.pose-btn {
				display: block;
				width: 100%;
				padding: 10px 12px;
				margin-bottom: 4px;
				background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				font-size: 12px;
				text-align: left;
				transition: all 0.2s;
			}
			.pose-btn:hover {
				background: linear-gradient(145deg, #fc5c7d, #6a82fb);
				transform: translateX(3px);
			}
			.pose-btn:disabled {
				background: #444;
				cursor: not-allowed;
				opacity: 0.5;
			}
			.pose-btn.active {
				background: linear-gradient(145deg, #fc5c7d, #6a82fb);
				box-shadow: 0 0 10px rgba(252, 92, 125, 0.5);
			}
			.controls-bar {
				padding: 15px;
				background: linear-gradient(145deg, #1a1a2e, #16213e);
				border-top: 1px solid #333;
			}
			.control-buttons {
				display: flex;
				gap: 8px;
				margin-bottom: 10px;
			}
			.control-buttons button {
				flex: 1;
				padding: 10px;
				background: linear-gradient(145deg, #6a82fb, #fc5c7d);
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				font-weight: bold;
				font-size: 12px;
				transition: all 0.2s;
			}
			.control-buttons button:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(106, 130, 251, 0.4);
			}
			.control-buttons button:disabled {
				background: #444;
				cursor: not-allowed;
				opacity: 0.5;
				transform: none;
				box-shadow: none;
			}
			.status {
				font-size: 11px;
				color: #888;
				text-align: center;
				padding: 5px;
				background: rgba(0, 0, 0, 0.3);
				border-radius: 4px;
			}
			.thumbnail-preview {
				display: none;
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				max-width: 80%;
				max-height: 80%;
				z-index: 200;
				border-radius: 10px;
				box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
			}
			.thumbnail-preview.show {
				display: block;
			}
			.overlay {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.7);
				z-index: 150;
			}
			.overlay.show {
				display: block;
			}
			.pose-info {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			.preview-icon {
				font-size: 10px;
				padding: 2px 6px;
				background: rgba(255,255,255,0.2);
				border-radius: 3px;
				cursor: pointer;
			}
			.preview-icon:hover {
				background: rgba(255,255,255,0.4);
			}
		</style>
	</head>

	<body>
		<div class="sidebar">
			<div class="sidebar-header">
				<h2>Lewd VRM Poses</h2>
				<div class="model-info">VRM Model: Default Model</div>
			</div>
			<div class="pose-categories" id="poseCategories">
				<!-- Pose categories will be dynamically generated -->
			</div>
			<div class="controls-bar">
				<div class="control-buttons">
					<button id="playBtn" disabled>Play</button>
					<button id="pauseBtn" disabled>Pause</button>
					<button id="stopBtn" disabled>Stop</button>
				</div>
				<div class="status" id="status">Loading VRM model...</div>
			</div>
		</div>
		<div class="overlay" id="overlay"></div>
		<img class="thumbnail-preview" id="thumbnailPreview" alt="Pose Preview" />

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
					"@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
					"@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3/lib/three-vrm-animation.module.min.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
			import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation'; 

			// DOM elements
			const poseCategoriesDiv = document.getElementById('poseCategories');
			const playBtn = document.getElementById('playBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const stopBtn = document.getElementById('stopBtn');
			const statusDiv = document.getElementById('status');
			const overlay = document.getElementById('overlay');
			const thumbnailPreview = document.getElementById('thumbnailPreview');

			// Configuration
			const POSES_CONFIG_URL = './VRMA/poses.json';
			const VRM_MODEL_URL = './VRM/5075840185788639488.vrm';

			// Pose data loaded from JSON
			let poseConfig = null;

			// Three.js Setup
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild(renderer.domElement);

			const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
			camera.position.set(0.0, 1.0, 5.0);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.screenSpacePanning = true;
			controls.target.set(0.0, 1.0, 0.0);
			controls.update();

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x1a1a2e);

			const light = new THREE.DirectionalLight(0xffffff, 3.0);
			light.position.set(1.0, 1.0, 1.0).normalize();
			scene.add(light);

			const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
			scene.add(ambientLight);

			// Global Variables for VRM and Animation
			let currentVrm = undefined;
			let currentMixer = undefined;
			let currentAction = undefined;
			let vrmaAnimationClip = undefined;
			let activePoseButton = null;

			// GLTF Loader with VRM and VRMA Plugins
			const loader = new GLTFLoader();
			loader.crossOrigin = 'anonymous';

			loader.register((parser) => {
				return new VRMLoaderPlugin(parser);
			});

			loader.register((parser) => {
				return new VRMAnimationLoaderPlugin(parser);
			});

			// Load pose configuration from JSON
			async function loadPoseConfig() {
				try {
					const response = await fetch(POSES_CONFIG_URL);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					poseConfig = await response.json();
					return poseConfig;
				} catch (error) {
					console.error('Error loading pose config:', error);
					statusDiv.textContent = 'Error loading pose configuration: ' + error.message;
					return null;
				}
			}

			// Validate path to prevent path traversal
			function isValidPath(path) {
				if (!path || typeof path !== 'string') return false;
				// Reject paths with traversal sequences or absolute paths
				return !path.includes('..') && !path.startsWith('/') && !path.includes('://');
			}

			// UI Generation
			function generatePoseUI() {
				if (!poseConfig) return;
				
				poseCategoriesDiv.innerHTML = '';
				
				for (const category of poseConfig.categories) {
					if (category.poses.length === 0) continue;
					if (!isValidPath(category.folder)) continue;
					
					const categoryDiv = document.createElement('div');
					categoryDiv.className = 'pose-category';
					
					const headerDiv = document.createElement('div');
					headerDiv.className = 'category-header';
					
					let previewUrl = null;
					if (category.preview && isValidPath(category.preview)) {
						previewUrl = encodeURIComponent(poseConfig.basePath + category.folder + '/' + category.preview);
					}
					
					headerDiv.innerHTML = `
						<div class="pose-info">
							<span>${category.name}</span>
							${previewUrl ? '<span class="preview-icon" data-preview="' + previewUrl + '">IMG</span>' : ''}
						</div>
						<span class="arrow">></span>
					`;
					
					const contentDiv = document.createElement('div');
					contentDiv.className = 'category-content';
					
					category.poses.forEach(pose => {
						const btn = document.createElement('button');
						btn.className = 'pose-btn';
						btn.textContent = pose.name;
						btn.disabled = true;
						btn.dataset.url = poseConfig.basePath + category.folder + '/' + pose.file;
						btn.addEventListener('click', () => loadPose(btn));
						contentDiv.appendChild(btn);
					});
					
					headerDiv.addEventListener('click', (e) => {
						if (e.target.classList.contains('preview-icon')) {
							showPreview(e.target.dataset.preview);
							return;
						}
						headerDiv.classList.toggle('expanded');
						contentDiv.classList.toggle('show');
					});
					
					categoryDiv.appendChild(headerDiv);
					categoryDiv.appendChild(contentDiv);
					poseCategoriesDiv.appendChild(categoryDiv);
				}
			}

			function showPreview(url) {
				const decodedUrl = decodeURIComponent(url);
				// Validate URL is a relative path within our VRMA folder
				if (!decodedUrl.startsWith('./VRMA/') || decodedUrl.includes('..')) {
					console.error('Invalid preview URL');
					return;
				}
				thumbnailPreview.src = decodedUrl;
				thumbnailPreview.classList.add('show');
				overlay.classList.add('show');
			}

			function hidePreview() {
				thumbnailPreview.classList.remove('show');
				overlay.classList.remove('show');
			}

			overlay.addEventListener('click', hidePreview);
			thumbnailPreview.addEventListener('click', hidePreview);

			async function loadPose(button) {
				const url = button.dataset.url;
				
				// Validate URL before loading
				if (!url || !url.startsWith('./VRMA/') || url.includes('..')) {
					statusDiv.textContent = 'Invalid pose URL';
					return;
				}
				
				// Update active state
				if (activePoseButton) {
					activePoseButton.classList.remove('active');
				}
				button.classList.add('active');
				activePoseButton = button;
				
				// Stop current animation
				if (currentAction) {
					currentAction.stop();
					currentAction = undefined;
				}
				vrmaAnimationClip = undefined;
				
				await loadVRMA(url);
			}

			// File Loading Functions
			async function loadVRM(url) {
				try {
					statusDiv.textContent = 'Loading VRM model...';
					
					return new Promise((resolve, reject) => {
						loader.load(
							url,
							(gltf) => {
								const vrm = gltf.userData.vrm;

								VRMUtils.removeUnnecessaryVertices(gltf.scene);
								VRMUtils.combineSkeletons(gltf.scene);
								VRMUtils.combineMorphs(vrm);

								vrm.scene.traverse((obj) => {
									obj.frustumCulled = false;
								});

								if (currentVrm) {
									scene.remove(currentVrm.scene);
									currentVrm.dispose();
								}

								scene.add(vrm.scene);
								vrm.scene.rotation.y = Math.PI;
								currentVrm = vrm;
								
								currentMixer = new THREE.AnimationMixer(vrm.scene);
								
								statusDiv.textContent = 'VRM model loaded! Select a pose.';
								console.log('VRM loaded:', vrm);
								
								resolve(vrm);
							},
							(progress) => {
								const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
								statusDiv.textContent = `Loading VRM... ${percent}%`;
							},
							(error) => {
								console.error('Error loading VRM:', error);
								statusDiv.textContent = 'Error loading VRM model';
								reject(error);
							}
						);
					});
				} catch (error) {
					console.error('Error in loadVRM:', error);
					statusDiv.textContent = 'Error loading VRM model';
				}
			}

			async function loadVRMA(url) {
				if (!currentVrm) {
					statusDiv.textContent = 'Please load a VRM model first.';
					return;
				}

				try {
					statusDiv.textContent = 'Loading pose animation...';
					
					return new Promise((resolve, reject) => {
						loader.load(
							url,
							(gltf) => {
								console.log('GLTF loaded (VRMA):', gltf);
								
								const vrmAnimationData = gltf.userData.vrmAnimations && gltf.userData.vrmAnimations[0];

								if (vrmAnimationData) {
									const clip = createVRMAnimationClip(vrmAnimationData, currentVrm);
									
									if (clip) {
										vrmaAnimationClip = clip;
										statusDiv.textContent = 'Pose loaded! Click Play to animate.';
										console.log('Generated AnimationClip:', vrmaAnimationClip);
										
										updateButtons();
										resolve(vrmaAnimationClip);
									} else {
										throw new Error('Could not create animation clip.');
									}
								} else {
									throw new Error('No valid VRMA animation found.');
								}
							},
							(progress) => {
								const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
								statusDiv.textContent = `Loading pose... ${percent}%`;
							},
							(error) => {
								console.error('Error loading animation:', error);
								statusDiv.textContent = 'Error loading pose: ' + error.message;
								reject(error);
							}
						);
					});
				} catch (error) {
					console.error('Error in loadVRMA:', error);
					statusDiv.textContent = 'Error loading pose animation';
				}
			}

			// Animation Control Functions
			function playAnimation() {
				if (currentVrm && vrmaAnimationClip && currentMixer) {
					if (currentAction) {
						currentAction.stop();
					}
					
					try {
						console.log('Playing animation...');
						
						currentAction = currentMixer.clipAction(vrmaAnimationClip);
						currentAction.setLoop(THREE.LoopRepeat);
						currentAction.clampWhenFinished = true;
						currentAction.reset();
						currentAction.play();
						
						statusDiv.textContent = `Playing (${vrmaAnimationClip.tracks.length} tracks, ${vrmaAnimationClip.duration.toFixed(2)}s)`;
						console.log('Animation started successfully.');
					} catch (error) {
						console.error('Error playing animation:', error);
						statusDiv.textContent = 'Error playing animation: ' + error.message;
					}
				} else {
					statusDiv.textContent = 'Load a VRM model and pose first.';
				}
			}

			function pauseAnimation() {
				if (currentAction) {
					currentAction.paused = !currentAction.paused;
					statusDiv.textContent = currentAction.paused ? 'Paused' : 'Playing...';
				}
			}

			function stopAnimation() {
				if (currentAction) {
					currentAction.stop();
					currentAction = undefined;
					currentMixer.stopAllAction();

					if (currentVrm) {
						currentVrm.humanoid.resetPose();
					}
					statusDiv.textContent = 'Stopped. Select a pose.';
				}
			}

			// UI and Event Handlers
			function updateButtons() {
				const hasVrm = currentVrm !== undefined;
				const hasVrma = vrmaAnimationClip !== undefined;
				
				// Enable pose buttons once VRM is loaded
				document.querySelectorAll('.pose-btn').forEach(btn => {
					btn.disabled = !hasVrm;
				});

				playBtn.disabled = !(hasVrm && hasVrma);
				pauseBtn.disabled = !(hasVrm && hasVrma);
				stopBtn.disabled = !(hasVrm && hasVrma);
			}

			playBtn.addEventListener('click', playAnimation);
			pauseBtn.addEventListener('click', pauseAnimation);
			stopBtn.addEventListener('click', stopAnimation);

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Helpers
			const gridHelper = new THREE.GridHelper(10, 10);
			scene.add(gridHelper);

			const axesHelper = new THREE.AxesHelper(5);
			scene.add(axesHelper);

			// Animation Loop
			const clock = new THREE.Clock();

			function animate() {
				requestAnimationFrame(animate);

				const deltaTime = clock.getDelta();

				if (currentVrm) {
					currentVrm.update(deltaTime);
				}
				if (currentMixer) {
					currentMixer.update(deltaTime);
				}

				controls.update();
				renderer.render(scene, camera);
			}

			animate();

			// Initial Load
			window.addEventListener('DOMContentLoaded', async () => {
				await loadPoseConfig();
				generatePoseUI();
				await loadVRM(VRM_MODEL_URL);
				updateButtons();
			});
		</script>
	</body>
</html>
