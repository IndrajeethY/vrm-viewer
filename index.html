<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Lewd VRM Poses Viewer</title>
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<style>
			body {
				margin: 0;
				font-family: 'Inter', sans-serif;
				overflow: hidden;
			}
			canvas {
				display: block;
				width: 100vw;
				height: 100vh;
			}
			.sidebar {
				position: absolute;
				top: 0;
				left: 0;
				width: 320px;
				height: 100vh;
				background: rgba(15, 15, 20, 0.95);
				color: white;
				z-index: 100;
				display: flex;
				flex-direction: column;
				box-shadow: 4px 0 15px rgba(0, 0, 0, 0.5);
				overflow: hidden;
			}
			.sidebar-header {
				padding: 15px;
				background: linear-gradient(145deg, #1a1a2e, #16213e);
				border-bottom: 1px solid #333;
			}
			.sidebar-header h2 {
				margin: 0 0 10px 0;
				font-size: 18px;
				color: #fc5c7d;
			}
			.sidebar-header .model-info {
				font-size: 12px;
				color: #888;
			}
			.pose-categories {
				flex: 1;
				overflow-y: auto;
				padding: 10px;
			}
			.pose-category {
				margin-bottom: 8px;
				border-radius: 8px;
				overflow: hidden;
				background: rgba(30, 30, 40, 0.8);
			}
			.category-header {
				padding: 12px 15px;
				background: linear-gradient(145deg, #2d2d44, #1f1f2e);
				cursor: pointer;
				display: flex;
				justify-content: space-between;
				align-items: center;
				font-weight: bold;
				font-size: 13px;
				transition: background 0.2s;
			}
			.category-header:hover {
				background: linear-gradient(145deg, #3d3d54, #2f2f3e);
			}
			.category-header .arrow {
				transition: transform 0.2s;
			}
			.category-header.expanded .arrow {
				transform: rotate(90deg);
			}
			.category-content {
				display: none;
				padding: 8px;
				background: rgba(20, 20, 30, 0.5);
			}
			.category-content.show {
				display: block;
			}
			.pose-btn {
				display: block;
				width: 100%;
				padding: 10px 12px;
				margin-bottom: 4px;
				background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				font-size: 12px;
				text-align: left;
				transition: all 0.2s;
			}
			.pose-btn:hover {
				background: linear-gradient(145deg, #fc5c7d, #6a82fb);
				transform: translateX(3px);
			}
			.pose-btn:disabled {
				background: #444;
				cursor: not-allowed;
				opacity: 0.5;
			}
			.pose-btn.active {
				background: linear-gradient(145deg, #fc5c7d, #6a82fb);
				box-shadow: 0 0 10px rgba(252, 92, 125, 0.5);
			}
			.controls-bar {
				padding: 15px;
				background: linear-gradient(145deg, #1a1a2e, #16213e);
				border-top: 1px solid #333;
			}
			.control-buttons {
				display: flex;
				gap: 8px;
				margin-bottom: 10px;
			}
			.control-buttons button {
				flex: 1;
				padding: 10px;
				background: linear-gradient(145deg, #6a82fb, #fc5c7d);
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				font-weight: bold;
				font-size: 12px;
				transition: all 0.2s;
			}
			.control-buttons button:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(106, 130, 251, 0.4);
			}
			.control-buttons button:disabled {
				background: #444;
				cursor: not-allowed;
				opacity: 0.5;
				transform: none;
				box-shadow: none;
			}
			.status {
				font-size: 11px;
				color: #888;
				text-align: center;
				padding: 5px;
				background: rgba(0, 0, 0, 0.3);
				border-radius: 4px;
			}
			.thumbnail-preview {
				display: none;
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				max-width: 80%;
				max-height: 80%;
				z-index: 200;
				border-radius: 10px;
				box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
			}
			.thumbnail-preview.show {
				display: block;
			}
			.overlay {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.7);
				z-index: 150;
			}
			.overlay.show {
				display: block;
			}
			.pose-info {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			.preview-icon {
				font-size: 10px;
				padding: 2px 6px;
				background: rgba(255,255,255,0.2);
				border-radius: 3px;
				cursor: pointer;
			}
			.preview-icon:hover {
				background: rgba(255,255,255,0.4);
			}
		</style>
	</head>

	<body>
		<div class="sidebar">
			<div class="sidebar-header">
				<h2>Lewd VRM Poses</h2>
				<div class="model-info">VRM Model: Default Model</div>
			</div>
			<div class="pose-categories" id="poseCategories">
				<!-- Pose categories will be dynamically generated -->
			</div>
			<div class="controls-bar">
				<div class="control-buttons">
					<button id="playBtn" disabled>Play</button>
					<button id="pauseBtn" disabled>Pause</button>
					<button id="stopBtn" disabled>Stop</button>
				</div>
				<div class="status" id="status">Loading VRM model...</div>
			</div>
		</div>
		<div class="overlay" id="overlay"></div>
		<img class="thumbnail-preview" id="thumbnailPreview" alt="Pose Preview" />

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
					"@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm'; 

			// DOM elements
			const poseCategoriesDiv = document.getElementById('poseCategories');
			const playBtn = document.getElementById('playBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const stopBtn = document.getElementById('stopBtn');
			const statusDiv = document.getElementById('status');
			const overlay = document.getElementById('overlay');
			const thumbnailPreview = document.getElementById('thumbnailPreview');

			// Configuration
			const POSES_CONFIG_URL = './VRMA/motion-Moves/poses.json';
			const VRM_MODEL_URL = './VRM/5075840185788639488.vrm';

			// Pose data loaded from JSON
			let poseConfig = null;

			// Three.js Setup
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild(renderer.domElement);

			const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
			camera.position.set(0.0, 1.0, 5.0);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.screenSpacePanning = true;
			controls.target.set(0.0, 1.0, 0.0);
			controls.update();

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x1a1a2e);

			const light = new THREE.DirectionalLight(0xffffff, 3.0);
			light.position.set(1.0, 1.0, 1.0).normalize();
			scene.add(light);

			const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
			scene.add(ambientLight);

			// Global Variables for VRM and Animation
			let currentVrm = undefined;
			let currentMixer = undefined;
			let currentAction = undefined;
			let fbxAnimationClip = undefined;
			let activePoseButton = null;

			// GLTF Loader with VRM Plugin (for VRM models)
			const loader = new GLTFLoader();
			loader.crossOrigin = 'anonymous';

			loader.register((parser) => {
				return new VRMLoaderPlugin(parser);
			});

			// FBX Loader for animations
			const fbxLoader = new FBXLoader();

			// Load pose configuration from JSON
			async function loadPoseConfig() {
				try {
					const response = await fetch(POSES_CONFIG_URL);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					poseConfig = await response.json();
					return poseConfig;
				} catch (error) {
					console.error('Error loading pose config:', error);
					statusDiv.textContent = 'Error loading pose configuration: ' + error.message;
					return null;
				}
			}

			// Validate path to prevent path traversal
			function isValidPath(path) {
				if (!path || typeof path !== 'string') return false;
				// Reject paths with traversal sequences or absolute paths
				return !path.includes('..') && !path.startsWith('/') && !path.includes('://');
			}

			// UI Generation
			function generatePoseUI() {
				if (!poseConfig) return;
				
				poseCategoriesDiv.innerHTML = '';
				
				for (const category of poseConfig.categories) {
					if (category.poses.length === 0) continue;
					
					const categoryDiv = document.createElement('div');
					categoryDiv.className = 'pose-category';
					
					const headerDiv = document.createElement('div');
					headerDiv.className = 'category-header';
					
					let previewUrl = null;
					if (category.preview && isValidPath(category.preview)) {
						previewUrl = encodeURIComponent(poseConfig.basePath + category.preview);
					}
					
					headerDiv.innerHTML = `
						<div class="pose-info">
							<span>${category.name}</span>
							${previewUrl ? '<span class="preview-icon" data-preview="' + previewUrl + '">IMG</span>' : ''}
						</div>
						<span class="arrow">></span>
					`;
					
					const contentDiv = document.createElement('div');
					contentDiv.className = 'category-content';
					
					category.poses.forEach(pose => {
						if (!isValidPath(pose.file)) return;
						const btn = document.createElement('button');
						btn.className = 'pose-btn';
						btn.textContent = pose.name;
						btn.disabled = true;
						btn.dataset.url = poseConfig.basePath + pose.file;
						btn.addEventListener('click', () => loadPose(btn));
						contentDiv.appendChild(btn);
					});
					
					headerDiv.addEventListener('click', (e) => {
						if (e.target.classList.contains('preview-icon')) {
							showPreview(e.target.dataset.preview);
							return;
						}
						headerDiv.classList.toggle('expanded');
						contentDiv.classList.toggle('show');
					});
					
					categoryDiv.appendChild(headerDiv);
					categoryDiv.appendChild(contentDiv);
					poseCategoriesDiv.appendChild(categoryDiv);
				}
			}

			function showPreview(url) {
				const decodedUrl = decodeURIComponent(url);
				// Validate URL is a relative path within our VRMA folder
				if (!decodedUrl.startsWith('./VRMA/') || decodedUrl.includes('..')) {
					console.error('Invalid preview URL');
					return;
				}
				thumbnailPreview.src = decodedUrl;
				thumbnailPreview.classList.add('show');
				overlay.classList.add('show');
			}

			function hidePreview() {
				thumbnailPreview.classList.remove('show');
				overlay.classList.remove('show');
			}

			overlay.addEventListener('click', hidePreview);
			thumbnailPreview.addEventListener('click', hidePreview);

			async function loadPose(button) {
				const url = button.dataset.url;
				
				// Validate URL before loading
				if (!url || !url.startsWith('./VRMA/motion-Moves/') || url.includes('..')) {
					statusDiv.textContent = 'Invalid pose URL';
					return;
				}
				
				// Update active state
				if (activePoseButton) {
					activePoseButton.classList.remove('active');
				}
				button.classList.add('active');
				activePoseButton = button;
				
				// Stop current animation
				if (currentAction) {
					currentAction.stop();
					currentAction = undefined;
				}
				fbxAnimationClip = undefined;
				
				await loadFBX(url);
			}

			// File Loading Functions
			async function loadVRM(url) {
				try {
					statusDiv.textContent = 'Loading VRM model...';
					
					return new Promise((resolve, reject) => {
						loader.load(
							url,
							(gltf) => {
								const vrm = gltf.userData.vrm;

								VRMUtils.removeUnnecessaryVertices(gltf.scene);
								VRMUtils.combineSkeletons(gltf.scene);
								VRMUtils.combineMorphs(vrm);

								vrm.scene.traverse((obj) => {
									obj.frustumCulled = false;
								});

								if (currentVrm) {
									scene.remove(currentVrm.scene);
									currentVrm.dispose();
								}

								scene.add(vrm.scene);
								vrm.scene.rotation.y = Math.PI;
								currentVrm = vrm;
								
								currentMixer = new THREE.AnimationMixer(vrm.scene);
								
								statusDiv.textContent = 'VRM model loaded! Select a pose.';
								console.log('VRM loaded:', vrm);
								
								resolve(vrm);
							},
							(progress) => {
								const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
								statusDiv.textContent = `Loading VRM... ${percent}%`;
							},
							(error) => {
								console.error('Error loading VRM:', error);
								statusDiv.textContent = 'Error loading VRM model';
								reject(error);
							}
						);
					});
				} catch (error) {
					console.error('Error in loadVRM:', error);
					statusDiv.textContent = 'Error loading VRM model';
				}
			}

			async function loadFBX(url) {
				if (!currentVrm) {
					statusDiv.textContent = 'Please load a VRM model first.';
					return;
				}

				try {
					statusDiv.textContent = 'Loading FBX animation...';
					
					return new Promise((resolve, reject) => {
						fbxLoader.load(
							url,
							(fbx) => {
								console.log('FBX loaded:', fbx);
								
								// Get the first animation clip from the FBX file
								if (fbx.animations && fbx.animations.length > 0) {
									const clip = fbx.animations[0];
									
									// Retarget the animation to the VRM model's bone structure
									const retargetedClip = retargetAnimation(clip, fbx, currentVrm);
									
									if (retargetedClip) {
										fbxAnimationClip = retargetedClip;
										statusDiv.textContent = 'Pose loaded! Click Play to animate.';
										console.log('Generated AnimationClip:', fbxAnimationClip);
										
										updateButtons();
										resolve(fbxAnimationClip);
									} else {
										throw new Error('Could not retarget animation clip.');
									}
								} else {
									throw new Error('No animations found in FBX file.');
								}
							},
							(progress) => {
								if (progress.total > 0) {
									const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
									statusDiv.textContent = `Loading pose... ${percent}%`;
								}
							},
							(error) => {
								console.error('Error loading FBX animation:', error);
								statusDiv.textContent = 'Error loading pose: ' + error.message;
								reject(error);
							}
						);
					});
				} catch (error) {
					console.error('Error in loadFBX:', error);
					statusDiv.textContent = 'Error loading FBX animation';
				}
			}

			// Build a comprehensive bone name mapping for FBX to VRM conversion
			function buildBoneNameMap() {
				const map = {};
				
				// Standard Mixamo bone name mappings (FBX to VRM humanoid bone names)
				const mixamoToVrm = {
					'mixamorigHips': 'hips',
					'mixamorigSpine': 'spine',
					'mixamorigSpine1': 'chest',
					'mixamorigSpine2': 'upperChest',
					'mixamorigNeck': 'neck',
					'mixamorigHead': 'head',
					'mixamorigLeftShoulder': 'leftShoulder',
					'mixamorigLeftArm': 'leftUpperArm',
					'mixamorigLeftForeArm': 'leftLowerArm',
					'mixamorigLeftHand': 'leftHand',
					'mixamorigRightShoulder': 'rightShoulder',
					'mixamorigRightArm': 'rightUpperArm',
					'mixamorigRightForeArm': 'rightLowerArm',
					'mixamorigRightHand': 'rightHand',
					'mixamorigLeftUpLeg': 'leftUpperLeg',
					'mixamorigLeftLeg': 'leftLowerLeg',
					'mixamorigLeftFoot': 'leftFoot',
					'mixamorigLeftToeBase': 'leftToes',
					'mixamorigRightUpLeg': 'rightUpperLeg',
					'mixamorigRightLeg': 'rightLowerLeg',
					'mixamorigRightFoot': 'rightFoot',
					'mixamorigRightToeBase': 'rightToes',
					// Finger bones
					'mixamorigLeftHandThumb1': 'leftThumbProximal',
					'mixamorigLeftHandThumb2': 'leftThumbIntermediate',
					'mixamorigLeftHandThumb3': 'leftThumbDistal',
					'mixamorigLeftHandIndex1': 'leftIndexProximal',
					'mixamorigLeftHandIndex2': 'leftIndexIntermediate',
					'mixamorigLeftHandIndex3': 'leftIndexDistal',
					'mixamorigLeftHandMiddle1': 'leftMiddleProximal',
					'mixamorigLeftHandMiddle2': 'leftMiddleIntermediate',
					'mixamorigLeftHandMiddle3': 'leftMiddleDistal',
					'mixamorigLeftHandRing1': 'leftRingProximal',
					'mixamorigLeftHandRing2': 'leftRingIntermediate',
					'mixamorigLeftHandRing3': 'leftRingDistal',
					'mixamorigLeftHandPinky1': 'leftLittleProximal',
					'mixamorigLeftHandPinky2': 'leftLittleIntermediate',
					'mixamorigLeftHandPinky3': 'leftLittleDistal',
					'mixamorigRightHandThumb1': 'rightThumbProximal',
					'mixamorigRightHandThumb2': 'rightThumbIntermediate',
					'mixamorigRightHandThumb3': 'rightThumbDistal',
					'mixamorigRightHandIndex1': 'rightIndexProximal',
					'mixamorigRightHandIndex2': 'rightIndexIntermediate',
					'mixamorigRightHandIndex3': 'rightIndexDistal',
					'mixamorigRightHandMiddle1': 'rightMiddleProximal',
					'mixamorigRightHandMiddle2': 'rightMiddleIntermediate',
					'mixamorigRightHandMiddle3': 'rightMiddleDistal',
					'mixamorigRightHandRing1': 'rightRingProximal',
					'mixamorigRightHandRing2': 'rightRingIntermediate',
					'mixamorigRightHandRing3': 'rightRingDistal',
					'mixamorigRightHandPinky1': 'rightLittleProximal',
					'mixamorigRightHandPinky2': 'rightLittleIntermediate',
					'mixamorigRightHandPinky3': 'rightLittleDistal',
				};
				
				// Alternative naming conventions (simple names without prefix)
				const simpleToVrm = {
					'Hips': 'hips',
					'Spine': 'spine',
					'Spine1': 'chest',
					'Spine2': 'upperChest',
					'Neck': 'neck',
					'Head': 'head',
					'LeftShoulder': 'leftShoulder',
					'LeftArm': 'leftUpperArm',
					'LeftForeArm': 'leftLowerArm',
					'LeftHand': 'leftHand',
					'RightShoulder': 'rightShoulder',
					'RightArm': 'rightUpperArm',
					'RightForeArm': 'rightLowerArm',
					'RightHand': 'rightHand',
					'LeftUpLeg': 'leftUpperLeg',
					'LeftLeg': 'leftLowerLeg',
					'LeftFoot': 'leftFoot',
					'LeftToeBase': 'leftToes',
					'RightUpLeg': 'rightUpperLeg',
					'RightLeg': 'rightLowerLeg',
					'RightFoot': 'rightFoot',
					'RightToeBase': 'rightToes',
				};
				
				// 3ds Max / Maya / Poser naming conventions
				const altToVrm = {
					'pelvis': 'hips',
					'Pelvis': 'hips',
					'hip': 'hips',
					'Hip': 'hips',
					'spine_01': 'spine',
					'spine_02': 'chest',
					'spine_03': 'upperChest',
					'clavicle_l': 'leftShoulder',
					'clavicle_r': 'rightShoulder',
					'upperarm_l': 'leftUpperArm',
					'upperarm_r': 'rightUpperArm',
					'lowerarm_l': 'leftLowerArm',
					'lowerarm_r': 'rightLowerArm',
					'hand_l': 'leftHand',
					'hand_r': 'rightHand',
					'thigh_l': 'leftUpperLeg',
					'thigh_r': 'rightUpperLeg',
					'calf_l': 'leftLowerLeg',
					'calf_r': 'rightLowerLeg',
					'foot_l': 'leftFoot',
					'foot_r': 'rightFoot',
					'ball_l': 'leftToes',
					'ball_r': 'rightToes',
					// Daz3D naming
					'abdomenLower': 'spine',
					'abdomenUpper': 'chest',
					'chestLower': 'chest',
					'chestUpper': 'upperChest',
					'lCollar': 'leftShoulder',
					'rCollar': 'rightShoulder',
					'lShldr': 'leftUpperArm',
					'rShldr': 'rightUpperArm',
					'lForeArm': 'leftLowerArm',
					'rForeArm': 'rightLowerArm',
					'lHand': 'leftHand',
					'rHand': 'rightHand',
					'lThigh': 'leftUpperLeg',
					'rThigh': 'rightUpperLeg',
					'lShin': 'leftLowerLeg',
					'rShin': 'rightLowerLeg',
					'lFoot': 'leftFoot',
					'rFoot': 'rightFoot',
				};
				
				// Combine all mappings
				Object.assign(map, mixamoToVrm, simpleToVrm, altToVrm);
				
				return map;
			}
			
			// Extract bone name from various FBX track name formats
			function extractBoneName(trackName) {
				// Handle different track name formats:
				// 1. "BoneName.property" (standard)
				// 2. "Armature|BoneName.property" (Blender export)
				// 3. "Root/BoneName.property" (hierarchy path)
				
				const dotIndex = trackName.lastIndexOf('.');
				if (dotIndex === -1) return null;
				
				let bonePath = trackName.substring(0, dotIndex);
				const property = trackName.substring(dotIndex + 1);
				
				// Handle Blender-style naming with |
				if (bonePath.includes('|')) {
					bonePath = bonePath.split('|').pop();
				}
				
				// Handle hierarchy paths with /
				if (bonePath.includes('/')) {
					bonePath = bonePath.split('/').pop();
				}
				
				return { boneName: bonePath, property: property };
			}
			
			// Find matching VRM bone by fuzzy matching
			function findMatchingVrmBone(fbxBoneName, boneNameMap) {
				// Direct match
				if (boneNameMap[fbxBoneName]) {
					return boneNameMap[fbxBoneName];
				}
				
				// Try case-insensitive match
				const lowerName = fbxBoneName.toLowerCase();
				for (const [key, value] of Object.entries(boneNameMap)) {
					if (key.toLowerCase() === lowerName) {
						return value;
					}
				}
				
				// Try partial matches for common patterns
				const patterns = [
					// Hips/Pelvis
					{ pattern: /hip|pelvis/i, vrm: 'hips' },
					{ pattern: /^spine$/i, vrm: 'spine' },
					{ pattern: /spine[_\s]?0?1|abdomen.*lower/i, vrm: 'spine' },
					{ pattern: /spine[_\s]?0?2|chest.*lower|abdomen.*upper/i, vrm: 'chest' },
					{ pattern: /spine[_\s]?0?3|chest.*upper|upper.*chest/i, vrm: 'upperChest' },
					{ pattern: /^neck$/i, vrm: 'neck' },
					{ pattern: /^head$/i, vrm: 'head' },
					// Left arm
					{ pattern: /l(eft)?[_\s]?(collar|shoulder|clavicle)/i, vrm: 'leftShoulder' },
					{ pattern: /l(eft)?[_\s]?(upper[_\s]?arm|shldr|arm(?!.*fore))/i, vrm: 'leftUpperArm' },
					{ pattern: /l(eft)?[_\s]?(fore[_\s]?arm|lower[_\s]?arm)/i, vrm: 'leftLowerArm' },
					{ pattern: /l(eft)?[_\s]?hand(?!.*thumb|index|middle|ring|pinky|little)/i, vrm: 'leftHand' },
					// Right arm
					{ pattern: /r(ight)?[_\s]?(collar|shoulder|clavicle)/i, vrm: 'rightShoulder' },
					{ pattern: /r(ight)?[_\s]?(upper[_\s]?arm|shldr|arm(?!.*fore))/i, vrm: 'rightUpperArm' },
					{ pattern: /r(ight)?[_\s]?(fore[_\s]?arm|lower[_\s]?arm)/i, vrm: 'rightLowerArm' },
					{ pattern: /r(ight)?[_\s]?hand(?!.*thumb|index|middle|ring|pinky|little)/i, vrm: 'rightHand' },
					// Left leg
					{ pattern: /l(eft)?[_\s]?(up[_\s]?leg|thigh|upper[_\s]?leg)/i, vrm: 'leftUpperLeg' },
					{ pattern: /l(eft)?[_\s]?(leg|calf|shin|lower[_\s]?leg)(?!.*up)/i, vrm: 'leftLowerLeg' },
					{ pattern: /l(eft)?[_\s]?foot/i, vrm: 'leftFoot' },
					{ pattern: /l(eft)?[_\s]?(toe|ball)/i, vrm: 'leftToes' },
					// Right leg
					{ pattern: /r(ight)?[_\s]?(up[_\s]?leg|thigh|upper[_\s]?leg)/i, vrm: 'rightUpperLeg' },
					{ pattern: /r(ight)?[_\s]?(leg|calf|shin|lower[_\s]?leg)(?!.*up)/i, vrm: 'rightLowerLeg' },
					{ pattern: /r(ight)?[_\s]?foot/i, vrm: 'rightFoot' },
					{ pattern: /r(ight)?[_\s]?(toe|ball)/i, vrm: 'rightToes' },
				];
				
				for (const { pattern, vrm } of patterns) {
					if (pattern.test(fbxBoneName)) {
						return vrm;
					}
				}
				
				return null;
			}
			
			// Retarget FBX animation to VRM humanoid bones
			function retargetAnimation(sourceClip, fbx, vrm) {
				const tracks = [];
				const humanoidBones = vrm.humanoid.normalizedHumanBones;
				const boneNameMap = buildBoneNameMap();
				
				// Log all tracks for debugging
				console.log('Source animation tracks:', sourceClip.tracks.map(t => t.name));
				
				// Build a map of FBX skeleton bones for reference
				const fbxBones = {};
				fbx.traverse((obj) => {
					if (obj.isBone) {
						fbxBones[obj.name] = obj;
					}
				});
				console.log('FBX bones found:', Object.keys(fbxBones));
				
				// Collect successfully mapped bones for logging
				const mappedBones = [];
				const unmappedBones = [];

				for (const track of sourceClip.tracks) {
					const parsed = extractBoneName(track.name);
					if (!parsed) continue;
					
					const { boneName, property } = parsed;
					
					// Find the VRM humanoid bone name using fuzzy matching
					const vrmBoneName = findMatchingVrmBone(boneName, boneNameMap);
					if (!vrmBoneName) {
						if (!unmappedBones.includes(boneName)) {
							unmappedBones.push(boneName);
						}
						continue;
					}
					
					// Get the VRM bone node
					const humanoidBone = humanoidBones[vrmBoneName];
					if (!humanoidBone || !humanoidBone.node) {
						continue;
					}
					
					if (!mappedBones.includes(`${boneName} -> ${vrmBoneName}`)) {
						mappedBones.push(`${boneName} -> ${vrmBoneName}`);
					}
					
					const vrmBoneNode = humanoidBone.node;
					
					// Create a new track with the VRM bone's name
					const newTrackName = vrmBoneNode.name + '.' + property;
					
					let newTrack;
					if (track.ValueTypeName === 'quaternion' || property === 'quaternion') {
						// Copy quaternion values directly - the coordinate systems should be compatible
						newTrack = new THREE.QuaternionKeyframeTrack(
							newTrackName,
							track.times,
							track.values.slice()
						);
					} else if (track.ValueTypeName === 'vector' || property === 'position' || property === 'scale') {
						// For position tracks, apply scaling (FBX often uses cm, VRM uses m)
						const values = track.values.slice();
						if (property === 'position') {
							// Scale positions - FBX files often use centimeters
							// Check if scaling is needed by examining the magnitude
							const avgMagnitude = Math.sqrt(
								values[0] * values[0] + values[1] * values[1] + values[2] * values[2]
							);
							// If values seem to be in cm (typical human hip height ~90-100cm), scale to meters
							if (avgMagnitude > 10) {
								for (let i = 0; i < values.length; i++) {
									values[i] *= 0.01; // Convert cm to m
								}
							}
						}
						newTrack = new THREE.VectorKeyframeTrack(
							newTrackName,
							track.times,
							values
						);
					} else {
						newTrack = track.clone();
						newTrack.name = newTrackName;
					}
					
					tracks.push(newTrack);
				}
				
				console.log('Bone mappings:', mappedBones);
				console.log('Unmapped bones:', unmappedBones);
				
				if (tracks.length === 0) {
					console.warn('No tracks could be retargeted. Attempting to use original animation on root bones.');
					// Try to create at least some animation by applying to the first available bone
					return sourceClip;
				}
				
				console.log(`Successfully retargeted ${tracks.length} tracks from ${sourceClip.tracks.length} original tracks`);
				return new THREE.AnimationClip(sourceClip.name || 'retargeted', sourceClip.duration, tracks);
			}

			// Animation Control Functions
			function playAnimation() {
				if (currentVrm && fbxAnimationClip && currentMixer) {
					if (currentAction) {
						currentAction.stop();
					}
					
					try {
						console.log('Playing animation...');
						
						currentAction = currentMixer.clipAction(fbxAnimationClip);
						currentAction.setLoop(THREE.LoopRepeat);
						currentAction.clampWhenFinished = true;
						currentAction.reset();
						currentAction.play();
						
						statusDiv.textContent = `Playing (${fbxAnimationClip.tracks.length} tracks, ${fbxAnimationClip.duration.toFixed(2)}s)`;
						console.log('Animation started successfully.');
					} catch (error) {
						console.error('Error playing animation:', error);
						statusDiv.textContent = 'Error playing animation: ' + error.message;
					}
				} else {
					statusDiv.textContent = 'Load a VRM model and pose first.';
				}
			}

			function pauseAnimation() {
				if (currentAction) {
					currentAction.paused = !currentAction.paused;
					statusDiv.textContent = currentAction.paused ? 'Paused' : 'Playing...';
				}
			}

			function stopAnimation() {
				if (currentAction) {
					currentAction.stop();
					currentAction = undefined;
					currentMixer.stopAllAction();

					if (currentVrm) {
						currentVrm.humanoid.resetPose();
					}
					statusDiv.textContent = 'Stopped. Select a pose.';
				}
			}

			// UI and Event Handlers
			function updateButtons() {
				const hasVrm = currentVrm !== undefined;
				const hasFbx = fbxAnimationClip !== undefined;
				
				// Enable pose buttons once VRM is loaded
				document.querySelectorAll('.pose-btn').forEach(btn => {
					btn.disabled = !hasVrm;
				});

				playBtn.disabled = !(hasVrm && hasFbx);
				pauseBtn.disabled = !(hasVrm && hasFbx);
				stopBtn.disabled = !(hasVrm && hasFbx);
			}

			playBtn.addEventListener('click', playAnimation);
			pauseBtn.addEventListener('click', pauseAnimation);
			stopBtn.addEventListener('click', stopAnimation);

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Helpers
			const gridHelper = new THREE.GridHelper(10, 10);
			scene.add(gridHelper);

			const axesHelper = new THREE.AxesHelper(5);
			scene.add(axesHelper);

			// Animation Loop
			const clock = new THREE.Clock();

			function animate() {
				requestAnimationFrame(animate);

				const deltaTime = clock.getDelta();

				if (currentVrm) {
					currentVrm.update(deltaTime);
				}
				if (currentMixer) {
					currentMixer.update(deltaTime);
				}

				controls.update();
				renderer.render(scene, camera);
			}

			animate();

			// Initial Load
			window.addEventListener('DOMContentLoaded', async () => {
				await loadPoseConfig();
				generatePoseUI();
				await loadVRM(VRM_MODEL_URL);
				updateButtons();
			});
		</script>
	</body>
</html>
